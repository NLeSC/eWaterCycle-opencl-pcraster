# Don't edit: generated by OperationsToWrappers.xsl
import types
import PCRaster._PCRaster as _PCRaster
def ifthen(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_IFTHEN)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("ifthen: %s" % (str(exception)))
def ifthenelse(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_IFTHENELSE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("ifthenelse: %s" % (str(exception)))
def pcrne(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_NE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrne: %s" % (str(exception)))
def pcreq(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_EQ)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcreq: %s" % (str(exception)))
def pcrgt(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_GT)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrgt: %s" % (str(exception)))
def pcrge(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_GE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrge: %s" % (str(exception)))
def pcrlt(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LT)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrlt: %s" % (str(exception)))
def pcrle(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrle: %s" % (str(exception)))
def min(arg1, *arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        arg2 = list(arg2)
        for i in range(len(arg2)):
            if isinstance(arg2[i], types.StringTypes):
                arg2[i] = _PCRaster.readmap(arg2[i])
            elif isinstance(arg2[i], types.IntType) or isinstance(arg2[i], types.LongType) or isinstance(arg2[i], types.FloatType):
                arg2[i] = _PCRaster.newNonSpatialField(arg2[i])
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MIN)
        results = []
        for i in range(len(arg2)):
            _PCRaster._rte().pushField(arg1)
            _PCRaster._rte().pushField(arg2[i])
            _PCRaster._rte().checkAndExec(operator, 2)
            arg1 = _PCRaster._rte().releasePopField()
        results.append(arg1)
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("min: %s" % (str(exception)))
def max(arg1, *arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        arg2 = list(arg2)
        for i in range(len(arg2)):
            if isinstance(arg2[i], types.StringTypes):
                arg2[i] = _PCRaster.readmap(arg2[i])
            elif isinstance(arg2[i], types.IntType) or isinstance(arg2[i], types.LongType) or isinstance(arg2[i], types.FloatType):
                arg2[i] = _PCRaster.newNonSpatialField(arg2[i])
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MAX)
        results = []
        for i in range(len(arg2)):
            _PCRaster._rte().pushField(arg1)
            _PCRaster._rte().pushField(arg2[i])
            _PCRaster._rte().checkAndExec(operator, 2)
            arg1 = _PCRaster._rte().releasePopField()
        results.append(arg1)
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("max: %s" % (str(exception)))
def cover(arg1, *arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        arg2 = list(arg2)
        for i in range(len(arg2)):
            if isinstance(arg2[i], types.StringTypes):
                arg2[i] = _PCRaster.readmap(arg2[i])
            elif isinstance(arg2[i], types.IntType) or isinstance(arg2[i], types.LongType) or isinstance(arg2[i], types.FloatType):
                arg2[i] = _PCRaster.newNonSpatialField(arg2[i])
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_COVER)
        results = []
        for i in range(len(arg2)):
            _PCRaster._rte().pushField(arg1)
            _PCRaster._rte().pushField(arg2[i])
            _PCRaster._rte().checkAndExec(operator, 2)
            arg1 = _PCRaster._rte().releasePopField()
        results.append(arg1)
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("cover: %s" % (str(exception)))
def timeinput(arg1):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_TIMEINPUT)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("timeinput: %s" % (str(exception)))
def timeinputsparse(arg1):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_TIMEINPUTSPARSE)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("timeinputsparse: %s" % (str(exception)))
def timeinputmodulo(arg1, arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_TIMEINPUTMODULO)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("timeinputmodulo: %s" % (str(exception)))
def lookupmapstack(arg1, arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LOOKUPMAPSTACK)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lookupmapstack: %s" % (str(exception)))
def spreadmax(arg1, arg2, arg3, arg4):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SPREADMAX)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().checkAndExec(operator, 4)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("spreadmax: %s" % (str(exception)))
def spreadmaxzone(arg1, arg2, arg3, arg4):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SPREADMAXZONE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().checkAndExec(operator, 4)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("spreadmaxzone: %s" % (str(exception)))
def spread(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SPREAD)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("spread: %s" % (str(exception)))
def spreadzone(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SPREADZONE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("spreadzone: %s" % (str(exception)))
def spreadldd(arg1, arg2, arg3, arg4):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SPREADLDD)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().checkAndExec(operator, 4)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("spreadldd: %s" % (str(exception)))
def spreadlddzone(arg1, arg2, arg3, arg4):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SPREADLDDZONE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().checkAndExec(operator, 4)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("spreadlddzone: %s" % (str(exception)))
def dynamicwaveq(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        if isinstance(arg6, types.StringTypes):
            arg6 = _PCRaster.readmap(arg6)
        elif isinstance(arg6, types.IntType) or isinstance(arg6, types.LongType) or isinstance(arg6, types.FloatType):
            arg6 = _PCRaster.newNonSpatialField(arg6)
        if isinstance(arg7, types.StringTypes):
            arg7 = _PCRaster.readmap(arg7)
        elif isinstance(arg7, types.IntType) or isinstance(arg7, types.LongType) or isinstance(arg7, types.FloatType):
            arg7 = _PCRaster.newNonSpatialField(arg7)
        if isinstance(arg8, types.StringTypes):
            arg8 = _PCRaster.readmap(arg8)
        elif isinstance(arg8, types.IntType) or isinstance(arg8, types.LongType) or isinstance(arg8, types.FloatType):
            arg8 = _PCRaster.newNonSpatialField(arg8)
        if isinstance(arg9, types.StringTypes):
            arg9 = _PCRaster.readmap(arg9)
        elif isinstance(arg9, types.IntType) or isinstance(arg9, types.LongType) or isinstance(arg9, types.FloatType):
            arg9 = _PCRaster.newNonSpatialField(arg9)
        if isinstance(arg10, types.StringTypes):
            arg10 = _PCRaster.readmap(arg10)
        elif isinstance(arg10, types.IntType) or isinstance(arg10, types.LongType) or isinstance(arg10, types.FloatType):
            arg10 = _PCRaster.newNonSpatialField(arg10)
        if isinstance(arg11, types.StringTypes):
            arg11 = _PCRaster.readmap(arg11)
        elif isinstance(arg11, types.IntType) or isinstance(arg11, types.LongType) or isinstance(arg11, types.FloatType):
            arg11 = _PCRaster.newNonSpatialField(arg11)
        if isinstance(arg12, types.StringTypes):
            arg12 = _PCRaster.readmap(arg12)
        elif isinstance(arg12, types.IntType) or isinstance(arg12, types.LongType) or isinstance(arg12, types.FloatType):
            arg12 = _PCRaster.newNonSpatialField(arg12)
        if isinstance(arg13, types.StringTypes):
            arg13 = _PCRaster.readmap(arg13)
        elif isinstance(arg13, types.IntType) or isinstance(arg13, types.LongType) or isinstance(arg13, types.FloatType):
            arg13 = _PCRaster.newNonSpatialField(arg13)
        if isinstance(arg14, types.StringTypes):
            arg14 = _PCRaster.readmap(arg14)
        elif isinstance(arg14, types.IntType) or isinstance(arg14, types.LongType) or isinstance(arg14, types.FloatType):
            arg14 = _PCRaster.newNonSpatialField(arg14)
        if isinstance(arg15, types.StringTypes):
            arg15 = _PCRaster.readmap(arg15)
        elif isinstance(arg15, types.IntType) or isinstance(arg15, types.LongType) or isinstance(arg15, types.FloatType):
            arg15 = _PCRaster.newNonSpatialField(arg15)
        if isinstance(arg16, types.StringTypes):
            arg16 = _PCRaster.readmap(arg16)
        elif isinstance(arg16, types.IntType) or isinstance(arg16, types.LongType) or isinstance(arg16, types.FloatType):
            arg16 = _PCRaster.newNonSpatialField(arg16)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DYNAMICWAVEQ)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().pushField(arg6)
        _PCRaster._rte().pushField(arg7)
        _PCRaster._rte().pushField(arg8)
        _PCRaster._rte().pushField(arg9)
        _PCRaster._rte().pushField(arg10)
        _PCRaster._rte().pushField(arg11)
        _PCRaster._rte().pushField(arg12)
        _PCRaster._rte().pushField(arg13)
        _PCRaster._rte().pushField(arg14)
        _PCRaster._rte().pushField(arg15)
        _PCRaster._rte().pushField(arg16)
        _PCRaster._rte().checkAndExec(operator, 16)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("dynamicwaveq: %s" % (str(exception)))
def dynamicwaveh(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        if isinstance(arg6, types.StringTypes):
            arg6 = _PCRaster.readmap(arg6)
        elif isinstance(arg6, types.IntType) or isinstance(arg6, types.LongType) or isinstance(arg6, types.FloatType):
            arg6 = _PCRaster.newNonSpatialField(arg6)
        if isinstance(arg7, types.StringTypes):
            arg7 = _PCRaster.readmap(arg7)
        elif isinstance(arg7, types.IntType) or isinstance(arg7, types.LongType) or isinstance(arg7, types.FloatType):
            arg7 = _PCRaster.newNonSpatialField(arg7)
        if isinstance(arg8, types.StringTypes):
            arg8 = _PCRaster.readmap(arg8)
        elif isinstance(arg8, types.IntType) or isinstance(arg8, types.LongType) or isinstance(arg8, types.FloatType):
            arg8 = _PCRaster.newNonSpatialField(arg8)
        if isinstance(arg9, types.StringTypes):
            arg9 = _PCRaster.readmap(arg9)
        elif isinstance(arg9, types.IntType) or isinstance(arg9, types.LongType) or isinstance(arg9, types.FloatType):
            arg9 = _PCRaster.newNonSpatialField(arg9)
        if isinstance(arg10, types.StringTypes):
            arg10 = _PCRaster.readmap(arg10)
        elif isinstance(arg10, types.IntType) or isinstance(arg10, types.LongType) or isinstance(arg10, types.FloatType):
            arg10 = _PCRaster.newNonSpatialField(arg10)
        if isinstance(arg11, types.StringTypes):
            arg11 = _PCRaster.readmap(arg11)
        elif isinstance(arg11, types.IntType) or isinstance(arg11, types.LongType) or isinstance(arg11, types.FloatType):
            arg11 = _PCRaster.newNonSpatialField(arg11)
        if isinstance(arg12, types.StringTypes):
            arg12 = _PCRaster.readmap(arg12)
        elif isinstance(arg12, types.IntType) or isinstance(arg12, types.LongType) or isinstance(arg12, types.FloatType):
            arg12 = _PCRaster.newNonSpatialField(arg12)
        if isinstance(arg13, types.StringTypes):
            arg13 = _PCRaster.readmap(arg13)
        elif isinstance(arg13, types.IntType) or isinstance(arg13, types.LongType) or isinstance(arg13, types.FloatType):
            arg13 = _PCRaster.newNonSpatialField(arg13)
        if isinstance(arg14, types.StringTypes):
            arg14 = _PCRaster.readmap(arg14)
        elif isinstance(arg14, types.IntType) or isinstance(arg14, types.LongType) or isinstance(arg14, types.FloatType):
            arg14 = _PCRaster.newNonSpatialField(arg14)
        if isinstance(arg15, types.StringTypes):
            arg15 = _PCRaster.readmap(arg15)
        elif isinstance(arg15, types.IntType) or isinstance(arg15, types.LongType) or isinstance(arg15, types.FloatType):
            arg15 = _PCRaster.newNonSpatialField(arg15)
        if isinstance(arg16, types.StringTypes):
            arg16 = _PCRaster.readmap(arg16)
        elif isinstance(arg16, types.IntType) or isinstance(arg16, types.LongType) or isinstance(arg16, types.FloatType):
            arg16 = _PCRaster.newNonSpatialField(arg16)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DYNAMICWAVEH)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().pushField(arg6)
        _PCRaster._rte().pushField(arg7)
        _PCRaster._rte().pushField(arg8)
        _PCRaster._rte().pushField(arg9)
        _PCRaster._rte().pushField(arg10)
        _PCRaster._rte().pushField(arg11)
        _PCRaster._rte().pushField(arg12)
        _PCRaster._rte().pushField(arg13)
        _PCRaster._rte().pushField(arg14)
        _PCRaster._rte().pushField(arg15)
        _PCRaster._rte().pushField(arg16)
        _PCRaster._rte().checkAndExec(operator, 16)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("dynamicwaveh: %s" % (str(exception)))
def order(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ORDER)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("order: %s" % (str(exception)))
def areaorder(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_AREAORDER)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("areaorder: %s" % (str(exception)))
def argorder(*arg1):
    try:
        arg1 = list(arg1)
        for i in range(len(arg1)):
            if isinstance(arg1[i], types.StringTypes):
                arg1[i] = _PCRaster.readmap(arg1[i])
            elif isinstance(arg1[i], types.IntType) or isinstance(arg1[i], types.LongType) or isinstance(arg1[i], types.FloatType):
                arg1[i] = _PCRaster.newNonSpatialField(arg1[i])
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ARGORDER)
        results = []
        results.append(arg0)
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("argorder: %s" % (str(exception)))
def argorderwithid(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ARGORDERWITHID)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("argorderwithid: %s" % (str(exception)))
def argorderarealimited(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ARGORDERAREALIMITED)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("argorderarealimited: %s" % (str(exception)))
def argorderwithidarealimited(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ARGORDERWITHIDAREALIMITED)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("argorderwithidarealimited: %s" % (str(exception)))
def argorderaddarealimited(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ARGORDERADDAREALIMITED)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("argorderaddarealimited: %s" % (str(exception)))
def argorderwithidaddarealimited(arg1, arg2, arg3, arg4):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ARGORDERWITHIDADDAREALIMITED)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().checkAndExec(operator, 4)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("argorderwithidaddarealimited: %s" % (str(exception)))
def windowminimum(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_WINDOWMINIMUM)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("windowminimum: %s" % (str(exception)))
def brenner(arg1, arg2, arg3, arg4, arg5, arg6):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        if isinstance(arg6, types.StringTypes):
            arg6 = _PCRaster.readmap(arg6)
        elif isinstance(arg6, types.IntType) or isinstance(arg6, types.LongType) or isinstance(arg6, types.FloatType):
            arg6 = _PCRaster.newNonSpatialField(arg6)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_BRENNER)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().pushField(arg6)
        _PCRaster._rte().checkAndExec(operator, 6)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("brenner: %s" % (str(exception)))
def windowmaximum(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_WINDOWMAXIMUM)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("windowmaximum: %s" % (str(exception)))
def areamaximum(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_AREAMAXIMUM)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("areamaximum: %s" % (str(exception)))
def areaminimum(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_AREAMINIMUM)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("areaminimum: %s" % (str(exception)))
def windowdiversity(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_WINDOWDIVERSITY)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("windowdiversity: %s" % (str(exception)))
def areadiversity(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_AREADIVERSITY)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("areadiversity: %s" % (str(exception)))
def areamajority(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_AREAMAJORITY)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("areamajority: %s" % (str(exception)))
def windowmajority(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_WINDOWMAJORITY)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("windowmajority: %s" % (str(exception)))
def pcrmul(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MUL)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrmul: %s" % (str(exception)))
def pcrfdiv(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_FDIV)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrfdiv: %s" % (str(exception)))
def pcrpow(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_POW)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrpow: %s" % (str(exception)))
def pcrmod(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MOD)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrmod: %s" % (str(exception)))
def pcridiv(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_IDIV)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcridiv: %s" % (str(exception)))
def pcruadd(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_UADD)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcruadd: %s" % (str(exception)))
def pcrumin(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_UMIN)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrumin: %s" % (str(exception)))
def pcrbadd(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_BADD)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrbadd: %s" % (str(exception)))
def pcrbmin(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_BMIN)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrbmin: %s" % (str(exception)))
def timeinputscalar(arg1, arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_TIMEINPUTSCALAR)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("timeinputscalar: %s" % (str(exception)))
def timeinputdirectional(arg1, arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_TIMEINPUTDIRECTIONAL)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("timeinputdirectional: %s" % (str(exception)))
def timeinputboolean(arg1, arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_TIMEINPUTBOOLEAN)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("timeinputboolean: %s" % (str(exception)))
def timeinputldd(arg1, arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_TIMEINPUTLDD)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("timeinputldd: %s" % (str(exception)))
def timeinputnominal(arg1, arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_TIMEINPUTNOMINAL)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("timeinputnominal: %s" % (str(exception)))
def timeinputordinal(arg1, arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_TIMEINPUTORDINAL)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("timeinputordinal: %s" % (str(exception)))
def lookupnominal(arg1, *arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        arg2 = list(arg2)
        for i in range(len(arg2)):
            if isinstance(arg2[i], types.StringTypes):
                arg2[i] = _PCRaster.readmap(arg2[i])
            elif isinstance(arg2[i], types.IntType) or isinstance(arg2[i], types.LongType) or isinstance(arg2[i], types.FloatType):
                arg2[i] = _PCRaster.newNonSpatialField(arg2[i])
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LOOKUPNOMINAL)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        for i in range(len(arg2)):
            _PCRaster._rte().pushField(arg2[i])
        _PCRaster._rte().checkAndExec(operator, 1 + len(arg2))
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lookupnominal: %s" % (str(exception)))
def lookupboolean(arg1, *arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        arg2 = list(arg2)
        for i in range(len(arg2)):
            if isinstance(arg2[i], types.StringTypes):
                arg2[i] = _PCRaster.readmap(arg2[i])
            elif isinstance(arg2[i], types.IntType) or isinstance(arg2[i], types.LongType) or isinstance(arg2[i], types.FloatType):
                arg2[i] = _PCRaster.newNonSpatialField(arg2[i])
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LOOKUPBOOLEAN)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        for i in range(len(arg2)):
            _PCRaster._rte().pushField(arg2[i])
        _PCRaster._rte().checkAndExec(operator, 1 + len(arg2))
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lookupboolean: %s" % (str(exception)))
def lookupordinal(arg1, *arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        arg2 = list(arg2)
        for i in range(len(arg2)):
            if isinstance(arg2[i], types.StringTypes):
                arg2[i] = _PCRaster.readmap(arg2[i])
            elif isinstance(arg2[i], types.IntType) or isinstance(arg2[i], types.LongType) or isinstance(arg2[i], types.FloatType):
                arg2[i] = _PCRaster.newNonSpatialField(arg2[i])
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LOOKUPORDINAL)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        for i in range(len(arg2)):
            _PCRaster._rte().pushField(arg2[i])
        _PCRaster._rte().checkAndExec(operator, 1 + len(arg2))
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lookupordinal: %s" % (str(exception)))
def lookupscalar(arg1, *arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        arg2 = list(arg2)
        for i in range(len(arg2)):
            if isinstance(arg2[i], types.StringTypes):
                arg2[i] = _PCRaster.readmap(arg2[i])
            elif isinstance(arg2[i], types.IntType) or isinstance(arg2[i], types.LongType) or isinstance(arg2[i], types.FloatType):
                arg2[i] = _PCRaster.newNonSpatialField(arg2[i])
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LOOKUPSCALAR)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        for i in range(len(arg2)):
            _PCRaster._rte().pushField(arg2[i])
        _PCRaster._rte().checkAndExec(operator, 1 + len(arg2))
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lookupscalar: %s" % (str(exception)))
def lookuplinear(arg1, arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LOOKUPLINEAR)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lookuplinear: %s" % (str(exception)))
def lookupdirectional(arg1, *arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        arg2 = list(arg2)
        for i in range(len(arg2)):
            if isinstance(arg2[i], types.StringTypes):
                arg2[i] = _PCRaster.readmap(arg2[i])
            elif isinstance(arg2[i], types.IntType) or isinstance(arg2[i], types.LongType) or isinstance(arg2[i], types.FloatType):
                arg2[i] = _PCRaster.newNonSpatialField(arg2[i])
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LOOKUPDIRECTIONAL)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        for i in range(len(arg2)):
            _PCRaster._rte().pushField(arg2[i])
        _PCRaster._rte().checkAndExec(operator, 1 + len(arg2))
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lookupdirectional: %s" % (str(exception)))
def lookupldd(arg1, *arg2):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        arg2 = list(arg2)
        for i in range(len(arg2)):
            if isinstance(arg2[i], types.StringTypes):
                arg2[i] = _PCRaster.readmap(arg2[i])
            elif isinstance(arg2[i], types.IntType) or isinstance(arg2[i], types.LongType) or isinstance(arg2[i], types.FloatType):
                arg2[i] = _PCRaster.newNonSpatialField(arg2[i])
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LOOKUPLDD)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        for i in range(len(arg2)):
            _PCRaster._rte().pushField(arg2[i])
        _PCRaster._rte().checkAndExec(operator, 1 + len(arg2))
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lookupldd: %s" % (str(exception)))
def indexnominal(arg1):
    raise RuntimeError("Only operations with map, table, timeseries arguments are currenly supported")
def indexboolean(arg1):
    raise RuntimeError("Only operations with map, table, timeseries arguments are currenly supported")
def indexordinal(arg1):
    raise RuntimeError("Only operations with map, table, timeseries arguments are currenly supported")
def indexscalar(arg1):
    raise RuntimeError("Only operations with map, table, timeseries arguments are currenly supported")
def indexdirectional(arg1):
    raise RuntimeError("Only operations with map, table, timeseries arguments are currenly supported")
def indexldd(arg1):
    raise RuntimeError("Only operations with map, table, timeseries arguments are currenly supported")
def indextable(arg1):
    raise RuntimeError("Only operations with map, table, timeseries arguments are currenly supported")
def index(arg1):
    raise RuntimeError("Only operations with map, table, timeseries arguments are currenly supported")
def ldd(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LDD)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("ldd: %s" % (str(exception)))
def directional(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DIRECTIONAL)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("directional: %s" % (str(exception)))
def scalar(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SCALAR)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("scalar: %s" % (str(exception)))
def boolean(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_BOOLEAN_)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("boolean: %s" % (str(exception)))
def nominal(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_NOMINAL)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("nominal: %s" % (str(exception)))
def ordinal(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ORDINAL)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("ordinal: %s" % (str(exception)))
def pcrand(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_AND_)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrand: %s" % (str(exception)))
def pcror(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_OR_)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcror: %s" % (str(exception)))
def pcrxor(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_XOR_)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrxor: %s" % (str(exception)))
def pcrnot(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_NOT_)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pcrnot: %s" % (str(exception)))
def sin(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SIN)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("sin: %s" % (str(exception)))
def cos(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_COS)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("cos: %s" % (str(exception)))
def tan(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_TAN)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("tan: %s" % (str(exception)))
def asin(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ASIN)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("asin: %s" % (str(exception)))
def acos(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACOS)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("acos: %s" % (str(exception)))
def atan(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ATAN)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("atan: %s" % (str(exception)))
def abs(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ABS)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("abs: %s" % (str(exception)))
def exp(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_EXP)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("exp: %s" % (str(exception)))
def fac(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_FAC)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("fac: %s" % (str(exception)))
def rounddown(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ROUNDDOWN)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("rounddown: %s" % (str(exception)))
def ln(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LN)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("ln: %s" % (str(exception)))
def log10(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LOG10)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("log10: %s" % (str(exception)))
def roundup(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ROUNDUP)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("roundup: %s" % (str(exception)))
def roundoff(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ROUNDOFF)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("roundoff: %s" % (str(exception)))
def sqrt(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SQRT)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("sqrt: %s" % (str(exception)))
def sqr(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SQR)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("sqr: %s" % (str(exception)))
def normal(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_NORMAL)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("normal: %s" % (str(exception)))
def uniform(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_UNIFORM)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("uniform: %s" % (str(exception)))
def xcoordinate(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_XCOORDINATE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("xcoordinate: %s" % (str(exception)))
def ycoordinate(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_YCOORDINATE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("ycoordinate: %s" % (str(exception)))
def uniqueid(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_UNIQUEID)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("uniqueid: %s" % (str(exception)))
def move(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MOVE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("move: %s" % (str(exception)))
def shift(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SHIFT)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("shift: %s" % (str(exception)))
def shift0(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SHIFT0)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("shift0: %s" % (str(exception)))
def celllength():
    try:
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_CELLLENGTH)
        results = []
        _PCRaster._rte().checkAndExec(operator, 0)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("celllength: %s" % (str(exception)))
def cellarea():
    try:
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_CELLAREA)
        results = []
        _PCRaster._rte().checkAndExec(operator, 0)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("cellarea: %s" % (str(exception)))
def time():
    try:
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_TIME)
        results = []
        _PCRaster._rte().checkAndExec(operator, 0)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("time: %s" % (str(exception)))
def timeslice():
    try:
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_TIMESLICE)
        results = []
        _PCRaster._rte().checkAndExec(operator, 0)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("timeslice: %s" % (str(exception)))
def mapnormal():
    try:
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MAPNORMAL)
        results = []
        _PCRaster._rte().checkAndExec(operator, 0)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("mapnormal: %s" % (str(exception)))
def mapuniform():
    try:
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MAPUNIFORM)
        results = []
        _PCRaster._rte().checkAndExec(operator, 0)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("mapuniform: %s" % (str(exception)))
def succ(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SUCC)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("succ: %s" % (str(exception)))
def pred(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_PRED)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pred: %s" % (str(exception)))
def pit(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_PIT)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("pit: %s" % (str(exception)))
def nodirection(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_NODIRECTION)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("nodirection: %s" % (str(exception)))
def mapminimum(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MAPMINIMUM)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("mapminimum: %s" % (str(exception)))
def mapmaximum(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MAPMAXIMUM)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("mapmaximum: %s" % (str(exception)))
def defined(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DEFINED)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("defined: %s" % (str(exception)))
def maparea(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MAPAREA)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("maparea: %s" % (str(exception)))
def spatial(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SPATIAL)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("spatial: %s" % (str(exception)))
def accustate(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUSTATE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accustate: %s" % (str(exception)))
def accuflux(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUFLUX)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accuflux: %s" % (str(exception)))
def muskingum(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        if isinstance(arg6, types.StringTypes):
            arg6 = _PCRaster.readmap(arg6)
        elif isinstance(arg6, types.IntType) or isinstance(arg6, types.LongType) or isinstance(arg6, types.FloatType):
            arg6 = _PCRaster.newNonSpatialField(arg6)
        if isinstance(arg7, types.StringTypes):
            arg7 = _PCRaster.readmap(arg7)
        elif isinstance(arg7, types.IntType) or isinstance(arg7, types.LongType) or isinstance(arg7, types.FloatType):
            arg7 = _PCRaster.newNonSpatialField(arg7)
        if isinstance(arg8, types.StringTypes):
            arg8 = _PCRaster.readmap(arg8)
        elif isinstance(arg8, types.IntType) or isinstance(arg8, types.LongType) or isinstance(arg8, types.FloatType):
            arg8 = _PCRaster.newNonSpatialField(arg8)
        if isinstance(arg9, types.StringTypes):
            arg9 = _PCRaster.readmap(arg9)
        elif isinstance(arg9, types.IntType) or isinstance(arg9, types.LongType) or isinstance(arg9, types.FloatType):
            arg9 = _PCRaster.newNonSpatialField(arg9)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MUSKINGUM)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().pushField(arg6)
        _PCRaster._rte().pushField(arg7)
        _PCRaster._rte().pushField(arg8)
        _PCRaster._rte().pushField(arg9)
        _PCRaster._rte().checkAndExec(operator, 9)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("muskingum: %s" % (str(exception)))
def dynwavestate(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        if isinstance(arg6, types.StringTypes):
            arg6 = _PCRaster.readmap(arg6)
        elif isinstance(arg6, types.IntType) or isinstance(arg6, types.LongType) or isinstance(arg6, types.FloatType):
            arg6 = _PCRaster.newNonSpatialField(arg6)
        if isinstance(arg7, types.StringTypes):
            arg7 = _PCRaster.readmap(arg7)
        elif isinstance(arg7, types.IntType) or isinstance(arg7, types.LongType) or isinstance(arg7, types.FloatType):
            arg7 = _PCRaster.newNonSpatialField(arg7)
        if isinstance(arg8, types.StringTypes):
            arg8 = _PCRaster.readmap(arg8)
        elif isinstance(arg8, types.IntType) or isinstance(arg8, types.LongType) or isinstance(arg8, types.FloatType):
            arg8 = _PCRaster.newNonSpatialField(arg8)
        if isinstance(arg9, types.StringTypes):
            arg9 = _PCRaster.readmap(arg9)
        elif isinstance(arg9, types.IntType) or isinstance(arg9, types.LongType) or isinstance(arg9, types.FloatType):
            arg9 = _PCRaster.newNonSpatialField(arg9)
        if isinstance(arg10, types.StringTypes):
            arg10 = _PCRaster.readmap(arg10)
        elif isinstance(arg10, types.IntType) or isinstance(arg10, types.LongType) or isinstance(arg10, types.FloatType):
            arg10 = _PCRaster.newNonSpatialField(arg10)
        if isinstance(arg11, types.StringTypes):
            arg11 = _PCRaster.readmap(arg11)
        elif isinstance(arg11, types.IntType) or isinstance(arg11, types.LongType) or isinstance(arg11, types.FloatType):
            arg11 = _PCRaster.newNonSpatialField(arg11)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DYNWAVESTATE)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().pushField(arg6)
        _PCRaster._rte().pushField(arg7)
        _PCRaster._rte().pushField(arg8)
        _PCRaster._rte().pushField(arg9)
        _PCRaster._rte().pushField(arg10)
        _PCRaster._rte().pushField(arg11)
        _PCRaster._rte().checkAndExec(operator, 11)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("dynwavestate: %s" % (str(exception)))
def dynwaveflux(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        if isinstance(arg6, types.StringTypes):
            arg6 = _PCRaster.readmap(arg6)
        elif isinstance(arg6, types.IntType) or isinstance(arg6, types.LongType) or isinstance(arg6, types.FloatType):
            arg6 = _PCRaster.newNonSpatialField(arg6)
        if isinstance(arg7, types.StringTypes):
            arg7 = _PCRaster.readmap(arg7)
        elif isinstance(arg7, types.IntType) or isinstance(arg7, types.LongType) or isinstance(arg7, types.FloatType):
            arg7 = _PCRaster.newNonSpatialField(arg7)
        if isinstance(arg8, types.StringTypes):
            arg8 = _PCRaster.readmap(arg8)
        elif isinstance(arg8, types.IntType) or isinstance(arg8, types.LongType) or isinstance(arg8, types.FloatType):
            arg8 = _PCRaster.newNonSpatialField(arg8)
        if isinstance(arg9, types.StringTypes):
            arg9 = _PCRaster.readmap(arg9)
        elif isinstance(arg9, types.IntType) or isinstance(arg9, types.LongType) or isinstance(arg9, types.FloatType):
            arg9 = _PCRaster.newNonSpatialField(arg9)
        if isinstance(arg10, types.StringTypes):
            arg10 = _PCRaster.readmap(arg10)
        elif isinstance(arg10, types.IntType) or isinstance(arg10, types.LongType) or isinstance(arg10, types.FloatType):
            arg10 = _PCRaster.newNonSpatialField(arg10)
        if isinstance(arg11, types.StringTypes):
            arg11 = _PCRaster.readmap(arg11)
        elif isinstance(arg11, types.IntType) or isinstance(arg11, types.LongType) or isinstance(arg11, types.FloatType):
            arg11 = _PCRaster.newNonSpatialField(arg11)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DYNWAVEFLUX)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().pushField(arg6)
        _PCRaster._rte().pushField(arg7)
        _PCRaster._rte().pushField(arg8)
        _PCRaster._rte().pushField(arg9)
        _PCRaster._rte().pushField(arg10)
        _PCRaster._rte().pushField(arg11)
        _PCRaster._rte().checkAndExec(operator, 11)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("dynwaveflux: %s" % (str(exception)))
def lookupstate(arg1, arg2, arg3, arg4, arg5):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LOOKUPSTATE)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().checkAndExec(operator, 5)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lookupstate: %s" % (str(exception)))
def lookuppotential(arg1, arg2, arg3, arg4, arg5):
    try:
        arg1 = _PCRaster.DataStorageId(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LOOKUPPOTENTIAL)
        results = []
        _PCRaster._rte().pushDataStorageId(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().checkAndExec(operator, 5)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lookuppotential: %s" % (str(exception)))
def accucapacitystate(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUCAPACITYSTATE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accucapacitystate: %s" % (str(exception)))
def accucapacityflux(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUCAPACITYFLUX)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accucapacityflux: %s" % (str(exception)))
def accuthresholdstate(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUTHRESHOLDSTATE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accuthresholdstate: %s" % (str(exception)))
def accuthresholdflux(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUTHRESHOLDFLUX)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accuthresholdflux: %s" % (str(exception)))
def accufractionstate(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUFRACTIONSTATE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accufractionstate: %s" % (str(exception)))
def accufractionflux(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUFRACTIONFLUX)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accufractionflux: %s" % (str(exception)))
def accutriggerstate(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUTRIGGERSTATE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accutriggerstate: %s" % (str(exception)))
def accutriggerflux(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUTRIGGERFLUX)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accutriggerflux: %s" % (str(exception)))
def accutraveltimestate(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUTRAVELTIMESTATE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accutraveltimestate: %s" % (str(exception)))
def accutraveltimeflux(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUTRAVELTIMEFLUX)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accutraveltimeflux: %s" % (str(exception)))
def accutraveltimefractionremoved(arg1, arg2, arg3, arg4):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUTRAVELTIMEFRACTIONREMOVED)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().checkAndExec(operator, 4)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accutraveltimefractionremoved: %s" % (str(exception)))
def accutraveltimefractionstate(arg1, arg2, arg3, arg4):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUTRAVELTIMEFRACTIONSTATE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().checkAndExec(operator, 4)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accutraveltimefractionstate: %s" % (str(exception)))
def accutraveltimefractionflux(arg1, arg2, arg3, arg4):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ACCUTRAVELTIMEFRACTIONFLUX)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().checkAndExec(operator, 4)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("accutraveltimefractionflux: %s" % (str(exception)))
def diffusestate(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DIFFUSESTATE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("diffusestate: %s" % (str(exception)))
def diffuseflux(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DIFFUSEFLUX)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("diffuseflux: %s" % (str(exception)))
def kinwavestate(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        if isinstance(arg6, types.StringTypes):
            arg6 = _PCRaster.readmap(arg6)
        elif isinstance(arg6, types.IntType) or isinstance(arg6, types.LongType) or isinstance(arg6, types.FloatType):
            arg6 = _PCRaster.newNonSpatialField(arg6)
        if isinstance(arg7, types.StringTypes):
            arg7 = _PCRaster.readmap(arg7)
        elif isinstance(arg7, types.IntType) or isinstance(arg7, types.LongType) or isinstance(arg7, types.FloatType):
            arg7 = _PCRaster.newNonSpatialField(arg7)
        if isinstance(arg8, types.StringTypes):
            arg8 = _PCRaster.readmap(arg8)
        elif isinstance(arg8, types.IntType) or isinstance(arg8, types.LongType) or isinstance(arg8, types.FloatType):
            arg8 = _PCRaster.newNonSpatialField(arg8)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_KINWAVESTATE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().pushField(arg6)
        _PCRaster._rte().pushField(arg7)
        _PCRaster._rte().pushField(arg8)
        _PCRaster._rte().checkAndExec(operator, 8)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("kinwavestate: %s" % (str(exception)))
def kinwaveflux(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        if isinstance(arg6, types.StringTypes):
            arg6 = _PCRaster.readmap(arg6)
        elif isinstance(arg6, types.IntType) or isinstance(arg6, types.LongType) or isinstance(arg6, types.FloatType):
            arg6 = _PCRaster.newNonSpatialField(arg6)
        if isinstance(arg7, types.StringTypes):
            arg7 = _PCRaster.readmap(arg7)
        elif isinstance(arg7, types.IntType) or isinstance(arg7, types.LongType) or isinstance(arg7, types.FloatType):
            arg7 = _PCRaster.newNonSpatialField(arg7)
        if isinstance(arg8, types.StringTypes):
            arg8 = _PCRaster.readmap(arg8)
        elif isinstance(arg8, types.IntType) or isinstance(arg8, types.LongType) or isinstance(arg8, types.FloatType):
            arg8 = _PCRaster.newNonSpatialField(arg8)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_KINWAVEFLUX)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().pushField(arg6)
        _PCRaster._rte().pushField(arg7)
        _PCRaster._rte().pushField(arg8)
        _PCRaster._rte().checkAndExec(operator, 8)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("kinwaveflux: %s" % (str(exception)))
def kinematic(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        if isinstance(arg6, types.StringTypes):
            arg6 = _PCRaster.readmap(arg6)
        elif isinstance(arg6, types.IntType) or isinstance(arg6, types.LongType) or isinstance(arg6, types.FloatType):
            arg6 = _PCRaster.newNonSpatialField(arg6)
        if isinstance(arg7, types.StringTypes):
            arg7 = _PCRaster.readmap(arg7)
        elif isinstance(arg7, types.IntType) or isinstance(arg7, types.LongType) or isinstance(arg7, types.FloatType):
            arg7 = _PCRaster.newNonSpatialField(arg7)
        if isinstance(arg8, types.StringTypes):
            arg8 = _PCRaster.readmap(arg8)
        elif isinstance(arg8, types.IntType) or isinstance(arg8, types.LongType) or isinstance(arg8, types.FloatType):
            arg8 = _PCRaster.newNonSpatialField(arg8)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_KINEMATIC)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().pushField(arg6)
        _PCRaster._rte().pushField(arg7)
        _PCRaster._rte().pushField(arg8)
        _PCRaster._rte().checkAndExec(operator, 8)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("kinematic: %s" % (str(exception)))
def timeoutput(arg1, arg2):
    raise RuntimeError("Only operations with map results are currenly supported")
def maptotal(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MAPTOTAL)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("maptotal: %s" % (str(exception)))
def mapand(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MAPAND)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("mapand: %s" % (str(exception)))
def mapor(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MAPOR)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("mapor: %s" % (str(exception)))
def areaarea(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_AREAAREA)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("areaarea: %s" % (str(exception)))
def clump(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_CLUMP)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("clump: %s" % (str(exception)))
def drain(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DRAIN)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("drain: %s" % (str(exception)))
def path(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_PATH)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("path: %s" % (str(exception)))
def aspect(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ASPECT)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("aspect: %s" % (str(exception)))
def slope(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SLOPE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("slope: %s" % (str(exception)))
def window4total(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_WINDOW4TOTAL)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("window4total: %s" % (str(exception)))
def profcurv(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_PROFCURV)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("profcurv: %s" % (str(exception)))
def plancurv(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_PLANCURV)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("plancurv: %s" % (str(exception)))
def view(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_VIEW)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("view: %s" % (str(exception)))
def inversedistance(arg1, arg2, arg3, arg4, arg5):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_INVERSEDISTANCE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().checkAndExec(operator, 5)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("inversedistance: %s" % (str(exception)))
def catchment(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_CATCHMENT)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("catchment: %s" % (str(exception)))
def subcatchment(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SUBCATCHMENT)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("subcatchment: %s" % (str(exception)))
def windowaverage(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_WINDOWAVERAGE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("windowaverage: %s" % (str(exception)))
def markwhilesumle(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MARKWHILESUMLE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("markwhilesumle: %s" % (str(exception)))
def markwhilesumge(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_MARKWHILESUMGE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("markwhilesumge: %s" % (str(exception)))
def ellipseaverage(arg1, arg2, arg3, arg4):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_ELLIPSEAVERAGE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().checkAndExec(operator, 4)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("ellipseaverage: %s" % (str(exception)))
def influencesimplegauss(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_INFLUENCESIMPLEGAUSS)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("influencesimplegauss: %s" % (str(exception)))
def distributesimplegauss(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DISTRIBUTESIMPLEGAUSS)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("distributesimplegauss: %s" % (str(exception)))
def ibngauss(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_IBNGAUSS)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("ibngauss: %s" % (str(exception)))
def horizontan(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_HORIZONTAN)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("horizontan: %s" % (str(exception)))
def catchmenttotal(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_CATCHMENTTOTAL)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("catchmenttotal: %s" % (str(exception)))
def areaaverage(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_AREAAVERAGE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("areaaverage: %s" % (str(exception)))
def areatotal(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_AREATOTAL)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("areatotal: %s" % (str(exception)))
def areauniform(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_AREAUNIFORM)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("areauniform: %s" % (str(exception)))
def areanormal(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_AREANORMAL)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("areanormal: %s" % (str(exception)))
def windowtotal(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_WINDOWTOTAL)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("windowtotal: %s" % (str(exception)))
def windowhighpass(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_WINDOWHIGHPASS)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("windowhighpass: %s" % (str(exception)))
def ldddist(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LDDDIST)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("ldddist: %s" % (str(exception)))
def upstream(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_UPSTREAM)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("upstream: %s" % (str(exception)))
def streamorder(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_STREAMORDER)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("streamorder: %s" % (str(exception)))
def transient(arg1, arg2, arg3, arg4, arg5, arg6, arg7):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        if isinstance(arg6, types.StringTypes):
            arg6 = _PCRaster.readmap(arg6)
        elif isinstance(arg6, types.IntType) or isinstance(arg6, types.LongType) or isinstance(arg6, types.FloatType):
            arg6 = _PCRaster.newNonSpatialField(arg6)
        if isinstance(arg7, types.StringTypes):
            arg7 = _PCRaster.readmap(arg7)
        elif isinstance(arg7, types.IntType) or isinstance(arg7, types.LongType) or isinstance(arg7, types.FloatType):
            arg7 = _PCRaster.newNonSpatialField(arg7)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_TRANSIENT)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().pushField(arg6)
        _PCRaster._rte().pushField(arg7)
        _PCRaster._rte().checkAndExec(operator, 7)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("transient: %s" % (str(exception)))
def downstream(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DOWNSTREAM)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("downstream: %s" % (str(exception)))
def downstreamdist(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DOWNSTREAMDIST)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("downstreamdist: %s" % (str(exception)))
def lddmask(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LDDMASK)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lddmask: %s" % (str(exception)))
def lddrepair(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LDDREPAIR)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lddrepair: %s" % (str(exception)))
def slopelength(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SLOPELENGTH)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("slopelength: %s" % (str(exception)))
def lddcreate(arg1, arg2, arg3, arg4, arg5):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LDDCREATE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().checkAndExec(operator, 5)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lddcreate: %s" % (str(exception)))
def lddcreatedem(arg1, arg2, arg3, arg4, arg5):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LDDCREATEDEM)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().checkAndExec(operator, 5)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lddcreatedem: %s" % (str(exception)))
def lddcreatend(arg1, arg2, arg3, arg4, arg5):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LDDCREATEND)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().checkAndExec(operator, 5)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lddcreatend: %s" % (str(exception)))
def lddcreatenddem(arg1, arg2, arg3, arg4, arg5):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        if isinstance(arg5, types.StringTypes):
            arg5 = _PCRaster.readmap(arg5)
        elif isinstance(arg5, types.IntType) or isinstance(arg5, types.LongType) or isinstance(arg5, types.FloatType):
            arg5 = _PCRaster.newNonSpatialField(arg5)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LDDCREATENDDEM)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().pushField(arg5)
        _PCRaster._rte().checkAndExec(operator, 5)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lddcreatenddem: %s" % (str(exception)))
def riksfraction(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_RIKSFRACTION)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("riksfraction: %s" % (str(exception)))
def squarefraction(arg1, arg2, arg3):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_SQUAREFRACTION)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().checkAndExec(operator, 3)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("squarefraction: %s" % (str(exception)))
def gradx(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_GRADX)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("gradx: %s" % (str(exception)))
def grady(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_GRADY)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("grady: %s" % (str(exception)))
def divergence(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DIVERGENCE)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("divergence: %s" % (str(exception)))
def diver(arg1, arg2, arg3, arg4):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        if isinstance(arg3, types.StringTypes):
            arg3 = _PCRaster.readmap(arg3)
        elif isinstance(arg3, types.IntType) or isinstance(arg3, types.LongType) or isinstance(arg3, types.FloatType):
            arg3 = _PCRaster.newNonSpatialField(arg3)
        if isinstance(arg4, types.StringTypes):
            arg4 = _PCRaster.readmap(arg4)
        elif isinstance(arg4, types.IntType) or isinstance(arg4, types.LongType) or isinstance(arg4, types.FloatType):
            arg4 = _PCRaster.newNonSpatialField(arg4)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_DIVER)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().pushField(arg3)
        _PCRaster._rte().pushField(arg4)
        _PCRaster._rte().checkAndExec(operator, 4)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("diver: %s" % (str(exception)))
def lax(arg1, arg2):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        if isinstance(arg2, types.StringTypes):
            arg2 = _PCRaster.readmap(arg2)
        elif isinstance(arg2, types.IntType) or isinstance(arg2, types.LongType) or isinstance(arg2, types.FloatType):
            arg2 = _PCRaster.newNonSpatialField(arg2)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LAX)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().pushField(arg2)
        _PCRaster._rte().checkAndExec(operator, 2)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("lax: %s" % (str(exception)))
def laplacian(arg1):
    try:
        if isinstance(arg1, types.StringTypes):
            arg1 = _PCRaster.readmap(arg1)
        elif isinstance(arg1, types.IntType) or isinstance(arg1, types.LongType) or isinstance(arg1, types.FloatType):
            arg1 = _PCRaster.newNonSpatialField(arg1)
        operator = _PCRaster._major2op(_PCRaster.MAJOR_CODE.OP_LAPLACIAN)
        results = []
        _PCRaster._rte().pushField(arg1)
        _PCRaster._rte().checkAndExec(operator, 1)
        results.append(_PCRaster._rte().releasePopField())
        return results[0]
    except RuntimeError, exception:
        raise RuntimeError("laplacian: %s" % (str(exception)))
