<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 6. Functional list of PCRaster operators</title><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><link rel="start" href="index.html" title="PCRaster Version 2 Manual"><link rel="up" href="index.html" title="PCRaster Version 2 Manual"><link rel="prev" href="ch05.html" title="Chapter 5. Dynamic modelling"><link rel="next" href="ch06s02.html" title="6.2. Neighbourhood operators"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 6. Functional list of PCRaster operators</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch06s02.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="secfunclist"></a>Chapter 6. Functional list of PCRaster operators</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="secpointop"></a>6.1. Point operators</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="groupbool"></a>6.1.1. Boolean operators</h3></div></div></div><p>
<b>and</b><br>
Performs a Boolean-AND operation on two expressions, on a cell-by-cell basis.<br>
<b>not</b><br>
Performs a Boolean-NOT operation on two expressions, on a cell-by-cell basis.<br>
<b>or</b><br>
Performs a Boolean-OR operation on two expressions, on a cell-by-cell basis.<br>
<b>xor</b><br>
Performs a Boolean-XOR operation on two expressions, on a cell-by-cell basis.<br>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="groupcomp"></a>6.1.2. Comparison operators</h3></div></div></div><p>
<b>eq or ==</b><br>
Performs a relational-equal-to operation on two expressions, on a cell-by-cell basis.<br>
<b>ge or &gt;=</b><br>
Performs a relational-greater-than-or-equal-to operation on two expressions, on a cell-by-cell basis.<br>
<b>gt or &gt;</b><br>
Performs a relational-greater-than operation on two expressions, on a cell-by-cell basis.<br>
<b>le or &lt;=</b><br>
Performs a relational-less-than-or-equal-to operation on two expressions, on a cell-by-cell basis.<br>
<b>lt or &lt;</b><br>
Performs a relational-less-than operation on two expressions, on a cell-by-cell basis.<br>
<b>ne or !=</b><br>
Performs a relational-not-equal-to operation on two expressions, on a cell-by-cell basis.<br>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="groupcond"></a>6.1.3. Conditional statements</h3></div></div></div><p>
<b>if then</b><br>
For each cell a Boolean expression determines whether the value of an expression or a missing value is assigned to the result<br>
<b>if then else</b><br>
For each cell a Boolean expression determines whether the value of the first expression or the value of a second expression is assigned to the result<br>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="groupmissvalue"></a>6.1.4. Missing value creation, detection, alteration</h3></div></div></div><p>
<b>cover</b><br>
Substitutes missing values on an expression for values selected from one or more different expression(s), on a cell-by-cell basis.<br>
<b>defined</b><br>
Assigns a Boolean TRUE for non missing values on the input expression and FALSE for missing values, on a cell-by-cell basis.<br>
<b>lddmask</b><br>
Cuts a local drain direction map resulting in a (smaller) sound local drain direction map.<br>
<b>nodirection</b><br>
For an expression of directional data type, returns TRUE for cells without a direction and FALSE otherwise for cells with a direction.<br>
<b>if then</b><br>
For each cell a Boolean expression determines whether the value of an expression or a missing value is assigned to the result<br>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="groupreltab"></a>6.1.5. Relations in tables</h3></div></div></div><p>
<b>lookup...</b><br>
For each cell, compares the cell value(s) of one or more expression(s) with the search key in a table and assigns a new value linked to that record in the key which matches the value(s) of the input expression<br>
<b>table</b><br>
Creates on basis of one or more maps a table with a score for each key in the table. The score is the total area of the cells that match the key in the table.<br>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="grouporder"></a>6.1.6. Order</h3></div></div></div><p>
<b>order</b><br>
Returns ordinal numbers to cells in ascending order.<br>
<b>areaorder</b><br>
Within each area ordinal numbers to cells in ascending order.<br>
<b>argorder,argorderwithid</b><br>
identify highest value by argument order<br>
<b>argorderarealimited,argorderwithidarealimited</b><br>
identify highest value by argument order with a limit per argument<br>
<b>pred</b><br>
For each cell returns an ordinal number which is the ordinal number of the next lower ordinal class (predecessor) on the expression.<br>
<b>succ</b><br>
For each cell returns an ordinal number which is the ordinal number of the next higher ordinal class (predecessor) on the expression.<br>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="groupmaxmin"></a>6.1.7. Maximize, minimize</h3></div></div></div><p>
<b>maximize</b><br>
For each cell, determines the maximum value of multiple expressions and assigns it to the corresponding cell for the result.<br>
<b>minimize</b><br>
For each cell, determines the minimum value of multiple expressions and assigns it to the corresponding cell for the result.<br>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="groupmath"></a>6.1.8. Arithmic operators, trigonometric, exponential, logarithmic functions</h3></div></div></div><p>
<b>*</b><br>
Multiplies the values of two expressions and sends this product to the result, on a cel-by-cell basis.<br>
<b>**</b><br>
Calculates the <span class="italic">n</span>th power of the first expression, where <span class="italic">n</span> is the value on a second expression and sends it to the result, on a cell-by-cell basis.<br>
<b>-</b><br>
Subtracts the value of the second expression from the value of the first expression and assigns it to the result, on a cell-by-cell basis.
<br>
<b>+</b><br>
Adds the values of two expressions and assigns this sum to the result, on a cell-by-cell basis.<br>
<b>/ of div</b><br>
Divides the value of a first expressions by the value of a second expression and assigns this quotient to the result, on a cell-by-cell basis.<br>
<b>abs</b><br>
Calculates the absolute value of an expression, on a cell-by-cell basis.<br>
<b>acos</b><br>
Calculates the inverse cosine value of an expression, on a cell-by-cell basis.<br>
<b>asin</b><br>
Calculates the inverse sine value of an expression, on a cell-by-cell basis.<br>
<b>atan</b><br>
Calculates the inverse tangent value of an expression, on a cell-by-cell basis.<br>
<b>cos</b><br>
Calculates the cosine of an expression, on a cell-by-cell basis.<br>
<b>exp</b><br>
Calculates the <span class="italic">base<sub>e</sub></span> exponential of an expression, on a cell-by-cell basis.<br>
<b>idiv</b><br>
Divides (integer division) the values on a first expression by the values on a second expression and assigns this quotient to the result, on a cell-by-cell basis.<br>
<b>ln</b><br>
Calculates the natural logarithm (<span class="italic">base<sub>e</sub></span>) exponential of an expression, on a cell-by-cell basis.<br>
<b>log10</b><br>
Calculates the (<span class="italic">base<sub>e</sub></span>) logarithm of an expression, on a cell-by-cell basis.<br>
<b>mod</b><br>
Divides (integer division) the values on a first expression by the values on a second expression and assigns the remainder to the result, on a cell-by-cell basis.<br>
<b>sin</b><br>
Calculates the sine of an expression, on a cell-by-cell basis.<br>
<b>sqr</b><br>
Calculates the square of an expression, on a cell-by-cell basis.<br>
<b>sqrt</b><br>
Calculates the square root of an expression, on a cell-by-cell basis.<br>
<b>tan</b><br>
Calculates the tangent of an expression, on a cell-by-cell basis.<br>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="groupround"></a>6.1.9. Rounding</h3></div></div></div><p>
<b>roundup</b><br>
For each cell, the value of an expression is rounded upwards. Values of the results will be whole numbers.<br>
<b>rounddown</b><br>
For each cell, the value of an expression is rounded downwards. Values of the results will be whole numbers.<br>
<b>roundoff</b><br>
For each cell, the value of an expression is rounded off. Values of the results will be whole numbers.<br>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="grouptypeconvers"></a>6.1.10. Data types: Conversion and assignment</h3></div></div></div><p>
<b>boolean</b><br>
Converts from nominal, ordinal, scalar, directional or ldd data type to a boolean data type or generates a map of boolean data type with one constant value.<br>
<b>directional</b><br>
Converts from boolean, nominal, ordinal, scalar or ldd data type to a directional data type or generates a map of directional data type with one constant value.<br>
<b>ldd</b><br>
Converts from boolean, nominal, ordinal, scalar or directional data type to a ldd data type or generates a map of ldd data type with one constant value.<br>
<b>nominal</b><br>
Converts from boolean, ordinal, scalar, directional or ldd data type to a nominal data type or generates a map of nominal data type with one constant value.<br>
<b>ordinal</b><br>
Converts from boolean, nominal, scalar, directional or ldd data type to a ordinal data type or generates a map of ordinal data type with one constant value.<br>
<b>scalar</b><br>
Converts from boolean, nominal, ordinal, directional or ldd data type to a scalar data type or generates a map of scalar data type with one constant value.<br>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="grouppointfield"></a>6.1.11. Random number generation - cells</h3></div></div></div><p>
<b>normal</b><br>
For each cell that is TRUE on a Boolean expression, assigns a value taken from a normal distribution with mean 0 and standard deviation 1.<br>
<b>uniform</b><br>
For each cell that is TRUE on a Boolean expression, assigns a value taken from a uniform distribution between 0 and 1.<br>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="groupcoord"></a>6.1.12. Coordinates, unique ID's</h3></div></div></div><p>
<b>uniqueid</b><br>
For each cell that is TRUE on a Boolean expression, assigns a unique whole value<br>
<b>xcoordinate</b><br>
For each cell that is TRUE on a Boolean expression, assigns the xcoordinate of the cell<br>
<b>ycoordinate</b><br>
For each cell that is TRUE on a Boolean expression, assigns the ycoordinate of the cell<br>
</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch06s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 5. Dynamic modelling </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 6.2. Neighbourhood operators</td></tr></table></div></body></html>
